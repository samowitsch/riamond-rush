var emitter = {
    events: {},
    publish: function publish(event, data) {
        if (this.events.hasOwnProperty(event)) this.events[event].forEach(function(listener) {
            return listener(data);
        });
    },
    subscribe: function subscribe(event, listener) {
        if (!this.events.hasOwnProperty(event)) this.events[event] = [];
        this.events[event].push(listener);
        return {
            unsubscribe: (function() {
                var index = this.events[event].indexOf(listener);
                if (-1 !== index) this.events[event].splice(index, 1);
            }).bind(this)
        };
    }
};
var EVENTS = {
    CONNECT: {
        NATIVE: "gamepadconnected",
        ALIAS: "connect"
    },
    DISCONNECT: {
        NATIVE: "gamepaddisconnected",
        ALIAS: "disconnect"
    },
    BUTTON_PRESS: {
        NATIVE: null,
        ALIAS: "button_press"
    },
    BUTTON_RELEASE: {
        NATIVE: null,
        ALIAS: "button_release"
    },
    AXIS_MOVEMENT: {
        NATIVE: null,
        ALIAS: "axis_move"
    }
};
var STICKS = {
    LEFT: {
        NAME: "left_stick",
        AXES: {
            X: 0,
            Y: 1
        }
    },
    RIGHT: {
        NAME: "right_stick",
        AXES: {
            X: 2,
            Y: 3
        }
    }
};
var DIRECTIONS = {
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom"
};
var BUTTON_MAPPING = {
    button_0: 0,
    button_1: 1,
    button_2: 2,
    button_3: 3,
    button_4: 4,
    button_5: 5,
    button_6: 6,
    button_7: 7,
    button_8: 8,
    button_9: 9,
    button_10: 10,
    button_11: 11,
    button_12: 12,
    button_13: 13,
    button_14: 14,
    button_15: 15,
    button_16: 16,
    button_17: 17
};
var AXIS_MOVEMENT_THRESHOLD = 0.8;
var log = function(message) {
    if (console.warn && "function" == typeof console.warn) console.warn(message);
    else console.log(message);
};
var findButtonMapping = function(index, mapping) {
    var results = [];
    Object.keys(mapping).forEach(function(key) {
        if (mapping[key] === index) results.push(key);
        else if (Array.isArray(mapping[key]) && -1 !== mapping[key].indexOf(index)) results.push(key);
    });
    return results;
};
var hasVibrationSupport = function(vibrationActuator) {
    return !!vibrationActuator && !!vibrationActuator.type && !!vibrationActuator.playEffect && "function" == typeof vibrationActuator.playEffect || false;
};
var hasGamepadApiSupport = function() {
    return !!window.navigator.getGamepads && "function" == typeof window.navigator.getGamepads || false;
};
var joypad = {
    loopStarted: false,
    instances: {},
    buttonEvents: {
        joypad: []
    },
    settings: {
        axisMovementThreshold: AXIS_MOVEMENT_THRESHOLD
    },
    remove: function remove(index) {
        return delete this.instances[index];
    },
    on: function on(event, callback) {
        switch(event){
            case EVENTS.CONNECT.ALIAS:
                return emitter.subscribe(EVENTS.CONNECT.ALIAS, callback);
            case EVENTS.DISCONNECT.ALIAS:
                return emitter.subscribe(EVENTS.DISCONNECT.ALIAS, callback);
            case EVENTS.BUTTON_PRESS.ALIAS:
                return emitter.subscribe(EVENTS.BUTTON_PRESS.ALIAS, callback);
            case EVENTS.BUTTON_RELEASE.ALIAS:
                return emitter.subscribe(EVENTS.BUTTON_RELEASE.ALIAS, callback);
            case EVENTS.AXIS_MOVEMENT.ALIAS:
                return emitter.subscribe(EVENTS.AXIS_MOVEMENT.ALIAS, callback);
        }
    },
    vibrate: function vibrate(gamepadInstance, options) {
        var vibrationActuator = gamepadInstance.vibrationActuator;
        var vibrationSettings = options ? options : this.settings.vibration;
        if (hasVibrationSupport(vibrationActuator)) {
            var type = vibrationActuator.type;
            return gamepadInstance.vibrationActuator.playEffect(type, vibrationSettings);
        }
        log("No vibration actuator interface found - https://developer.mozilla.org/en-US/docs/Web/API/GamepadHapticActuator");
    },
    set: function set(settings) {
        var axisMovementThreshold = settings.axisMovementThreshold, vibration = settings.vibration, customButtonMapping = settings.customButtonMapping;
        var parsedValue = parseFloat(axisMovementThreshold);
        if (!isNaN(parsedValue)) this.settings.axisMovementThreshold = parsedValue;
        this.settings.vibration = vibration;
        this.settings.customButtonMapping = customButtonMapping;
    },
    trigger: function trigger(event, data) {
        return emitter.publish(event, data);
    }
};
var listenToButtonEvents = function(gamepad) {
    gamepad.buttons.forEach(function(button, index) {
        var customButtonMapping = joypad.settings.customButtonMapping;
        var buttonMapping = customButtonMapping ? customButtonMapping : BUTTON_MAPPING;
        var keys = findButtonMapping(index, buttonMapping);
        var buttonEvents = joypad.buttonEvents;
        if (keys && keys.length) keys.forEach(function(key) {
            if (button.pressed) {
                if (!buttonEvents.joypad[gamepad.index][key]) buttonEvents.joypad[gamepad.index][key] = {
                    pressed: true,
                    hold: false,
                    released: false
                };
                buttonEvents.joypad[gamepad.index][key].button = button;
                buttonEvents.joypad[gamepad.index][key].index = index;
                buttonEvents.joypad[gamepad.index][key].gamepad = gamepad;
            } else if (!button.pressed && buttonEvents.joypad[gamepad.index][key]) {
                buttonEvents.joypad[gamepad.index][key].released = true;
                buttonEvents.joypad[gamepad.index][key].hold = false;
            }
        });
    });
};
var listenToAxisMovements = function(gamepad) {
    var axisMovementEvent = function(eventData) {
        return new CustomEvent(EVENTS.AXIS_MOVEMENT.ALIAS, {
            detail: eventData
        });
    };
    var axisMovementThreshold = joypad.settings.axisMovementThreshold;
    var axes = gamepad.axes;
    var totalAxisIndexes = axes.length;
    var totalSticks = totalAxisIndexes / 2;
    axes.forEach(function(axis, index) {
        if (Math.abs(axis) > axisMovementThreshold) {
            var stickMoved = null;
            var directionOfMovement = null;
            var axisMovementValue = axis;
            stickMoved = index < totalSticks ? STICKS.LEFT.NAME : STICKS.RIGHT.NAME;
            if (index === STICKS.LEFT.AXES.X || index === STICKS.RIGHT.AXES.X) directionOfMovement = axis < 0 ? DIRECTIONS.LEFT : DIRECTIONS.RIGHT;
            if (index === STICKS.LEFT.AXES.Y || index === STICKS.RIGHT.AXES.Y) directionOfMovement = axis < 0 ? DIRECTIONS.TOP : DIRECTIONS.BOTTOM;
            var eventData = {
                gamepad: gamepad,
                totalSticks: totalSticks,
                stickMoved: stickMoved,
                directionOfMovement: directionOfMovement,
                axisMovementValue: axisMovementValue,
                axis: index
            };
            return window.dispatchEvent(axisMovementEvent(eventData));
        }
    });
};
var handleButtonEvent = function(buttonName, buttonEvents) {
    if (buttonEvents[buttonName].pressed) {
        dispatchCustomEvent(EVENTS.BUTTON_PRESS.ALIAS, buttonEvents, buttonName);
        buttonEvents[buttonName].pressed = false;
        buttonEvents[buttonName].hold = true;
        buttonEvents[buttonName].last_event = EVENTS.BUTTON_PRESS.ALIAS;
    } else if (buttonEvents[buttonName].hold) ;
    else if (buttonEvents[buttonName].released && buttonEvents[buttonName].last_event === EVENTS.BUTTON_PRESS.ALIAS) {
        dispatchCustomEvent(EVENTS.BUTTON_RELEASE.ALIAS, buttonEvents, buttonName);
        delete buttonEvents[buttonName];
    }
};
var loop = {
    id: null,
    start: function start() {
        var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
        var buttonEvents = joypad.buttonEvents;
        var gamepads = window.navigator.getGamepads();
        gamepads = Array.prototype.slice.call(gamepads);
        gamepads.forEach(function(gamepad, index) {
            if (gamepad) {
                if (!buttonEvents.joypad[index]) buttonEvents.joypad[index] = {};
                joypad.instances[index] = gamepad;
                listenToButtonEvents(gamepad);
                listenToAxisMovements(gamepad);
            }
        });
        buttonEvents.joypad.forEach(function(events) {
            if (events) Object.keys(events).forEach(function(key) {
                handleButtonEvent(key, events);
            });
        });
        this.id = requestAnimationFrame(this.start.bind(this));
    },
    stop: function stop(id) {
        var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;
        return cancelAnimationFrame(id);
    }
};
var initEventListeners = function() {
    window.addEventListener(EVENTS.CONNECT.NATIVE, function(e) {
        emitter.publish(EVENTS.CONNECT.ALIAS, e);
        if (!joypad.loopStarted) {
            joypad.loopStarted = true;
            return loop.start();
        }
    });
    window.addEventListener(EVENTS.DISCONNECT.NATIVE, function(e) {
        emitter.publish(EVENTS.DISCONNECT.ALIAS, e);
        joypad.remove(e.gamepad.index);
        joypad.buttonEvents.joypad[e.gamepad.index] = null;
        if (!Object.keys(joypad.instances).length) {
            joypad.loopStarted = false;
            return loop.stop(loop.id);
        }
    });
    window.addEventListener(EVENTS.BUTTON_PRESS.ALIAS, function(e) {
        return emitter.publish(EVENTS.BUTTON_PRESS.ALIAS, e);
    });
    window.addEventListener(EVENTS.BUTTON_RELEASE.ALIAS, function(e) {
        return emitter.publish(EVENTS.BUTTON_RELEASE.ALIAS, e);
    });
    window.addEventListener(EVENTS.AXIS_MOVEMENT.ALIAS, function(e) {
        return emitter.publish(EVENTS.AXIS_MOVEMENT.ALIAS, e);
    });
};
var dispatchCustomEvent = function(eventName, buttonEvents, buttonName) {
    var joypadEvent = function(eventData) {
        return new CustomEvent(eventName, {
            detail: eventData
        });
    };
    var _buttonEvents_buttonName = buttonEvents[buttonName], index = _buttonEvents_buttonName.index, gamepad = _buttonEvents_buttonName.gamepad;
    var eventData = {
        buttonName: buttonName,
        button: buttonEvents[buttonName].button,
        index: index,
        gamepad: gamepad
    };
    window.dispatchEvent(joypadEvent(eventData));
};
initEventListeners();
if (hasGamepadApiSupport()) window.joypad = joypad;
else {
    window.joypad = {};
    log("Your browser does not support the Gamepad API - https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API");
}
